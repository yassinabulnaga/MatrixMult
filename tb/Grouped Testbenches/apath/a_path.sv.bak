// ====================== tb_64x64_matmul.sv ======================
// Testbench for 64x64 Matrix Multiplication using 16x16 PE Array
// Processes matrices in 4x4 grid of 16x16 tiles

`timescale 1ns/1ps

module tb_64x64_matmul;

  import mm_pkg::*;

  // Matrix dimensions
  localparam int MAT_SIZE = 64;
  localparam int NUM_TILES = MAT_SIZE / T;  // 4 tiles per dimension

  // ------------------------------------------------------------
  // Clock and reset
  // ------------------------------------------------------------
  logic clk;
  logic rst_n;

  // 100 MHz clock
  initial begin
    clk = 0;
    forever #5 clk = ~clk;
  end

  // ------------------------------------------------------------
  // BRAM A (Matrix A storage) - needs 64*64 = 4096 elements
  // ------------------------------------------------------------
  logic [T-1:0]          bram_a_en;
  logic [T-1:0][11:0]    bram_a_addr;   // 4096 depth needs 12 bits
  logic [T-1:0][W-1:0]   bram_a_din;
  logic [T-1:0]          bram_a_we;
  logic [T-1:0][W/8-1:0] bram_a_be;
  logic [T-1:0][W-1:0]   bram_a_dout;

  m10k_banks #(
    .N_BANKS       (T),
    .W             (W),
    .DEPTH_PER_BANK(4096),
    .USE_BYTE_EN   (0),
    .RDW_MODE      (0)
  ) bram_a (
    .clk     (clk),
    .rst_n   (rst_n),
    .a_en    (bram_a_en),
    .a_addr  (bram_a_addr),
    .a_din   (bram_a_din),
    .a_we    (bram_a_we),
    .a_be    (bram_a_be),
    .a_dout  (bram_a_dout),
    .b_en    ('0),
    .b_addr  ('0),
    .b_din   ('0),
    .b_we    ('0),
    .b_be    ('0),
    .b_dout  ()
  );

  // ------------------------------------------------------------
  // BRAM B (Matrix B storage)
  // ------------------------------------------------------------
  logic [T-1:0]          bram_b_en;
  logic [T-1:0][11:0]    bram_b_addr;
  logic [T-1:0][W-1:0]   bram_b_din;
  logic [T-1:0]          bram_b_we;
  logic [T-1:0][W/8-1:0] bram_b_be;
  logic [T-1:0][W-1:0]   bram_b_dout;

  m10k_banks #(
    .N_BANKS       (T),
    .W             (W),
    .DEPTH_PER_BANK(4096),
    .USE_BYTE_EN   (0),
    .RDW_MODE      (0)
  ) bram_b (
    .clk     (clk),
    .rst_n   (rst_n),
    .a_en    (bram_b_en),
    .a_addr  (bram_b_addr),
    .a_din   (bram_b_din),
    .a_we    (bram_b_we),
    .a_be    (bram_b_be),
    .a_dout  (bram_b_dout),
    .b_en    ('0),
    .b_addr  ('0),
    .b_din   ('0),
    .b_we    ('0),
    .b_be    ('0),
    .b_dout  ()
  );

  // ------------------------------------------------------------
  // PE Array
  // ------------------------------------------------------------
  logic [T-1:0][W-1:0]      pe_a_in_row;
  logic [T-1:0]             pe_a_in_valid;
  logic [T-1:0][W-1:0]      pe_b_in_col;
  logic [T-1:0]             pe_b_in_valid;
  logic                     pe_acc_clear_block;
  logic                     pe_drain_pulse;
  logic [T-1:0][T-1:0][ACCW-1:0] pe_acc_mat;
  logic [T-1:0][T-1:0]      pe_acc_v_mat;

  pe_array #(
    .W        (W),
    .ACCW     (ACCW),
    .T        (T),
    .SIGNED_M (SIGNED_M),
    .PIPE_MUL (PIPE_MUL)
  ) dut_pe_array (
    .clk            (clk),
    .rst_n          (rst_n),
    .a_in_row       (pe_a_in_row),
    .a_in_valid     (pe_a_in_valid),
    .b_in_col       (pe_b_in_col),
    .b_in_valid     (pe_b_in_valid),
    .acc_clear_block(pe_acc_clear_block),
    .drain_pulse    (pe_drain_pulse),
    .acc_mat        (pe_acc_mat),
    .acc_v_mat      (pe_acc_v_mat)
  );

  // ------------------------------------------------------------
  // BRAM C (result storage) - 64x64 results
  // ------------------------------------------------------------
  logic [T-1:0]               bram_c_en;
  logic [T-1:0][11:0]         bram_c_addr;
  logic [T-1:0][ACCW-1:0]     bram_c_din;
  logic [T-1:0]               bram_c_we;
  logic [T-1:0][ACCW/8-1:0]   bram_c_be;
  logic [T-1:0][ACCW-1:0]     bram_c_dout;

  m10k_banks #(
    .N_BANKS       (T),
    .W             (ACCW),
    .DEPTH_PER_BANK(4096),
    .USE_BYTE_EN   (0),
    .RDW_MODE      (0)
  ) bram_c (
    .clk     (clk),
    .rst_n   (rst_n),
    .a_en    (bram_c_en),
    .a_addr  (bram_c_addr),
    .a_din   (bram_c_din),
    .a_we    (bram_c_we),
    .a_be    (bram_c_be),
    .a_dout  (bram_c_dout),
    .b_en    ('0),
    .b_addr  ('0),
    .b_din   ('0),
    .b_we    ('0),
    .b_be    ('0),
    .b_dout  ()
  );

  // ------------------------------------------------------------
  // Pipeline registers
  // ------------------------------------------------------------
  logic [T-1:0][W-1:0] bram_a_dout_q;
  logic [T-1:0]        bram_a_valid_q, bram_a_valid_q2;
  logic [T-1:0][W-1:0] bram_b_dout_q;
  logic [T-1:0]        bram_b_valid_q, bram_b_valid_q2;

  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      bram_a_dout_q   <= '0;
      bram_a_valid_q  <= '0;
      bram_a_valid_q2 <= '0;
      bram_b_dout_q   <= '0;
      bram_b_valid_q  <= '0;
      bram_b_valid_q2 <= '0;
    end else begin
      bram_a_valid_q  <= bram_a_en;
      bram_b_valid_q  <= bram_b_en;
      bram_a_valid_q2 <= bram_a_valid_q;
      bram_b_valid_q2 <= bram_b_valid_q;
      bram_a_dout_q   <= bram_a_dout;
      bram_b_dout_q   <= bram_b_dout;
    end
  end

  assign pe_a_in_row   = bram_a_dout_q;
  assign pe_a_in_valid = bram_a_valid_q2;
  assign pe_b_in_col   = bram_b_dout_q;
  assign pe_b_in_valid = bram_b_valid_q2;

  // ------------------------------------------------------------
  // Helper Tasks for 64x64 operations
  // ------------------------------------------------------------

  // Write full 64x64 Matrix A to BRAM A
  // Storage: Bank i holds rows i, i+16, i+32, i+48
  // Within each bank, store row-major
  task automatic write_matrix_64x64_a(input logic [63:0][63:0][W-1:0] mat);
    int row, col, bank, addr, tile_row;
    $display("  Writing 64x64 Matrix A to BRAM...");

    bram_a_en = '0;
    bram_a_we = '0;

    for (row = 0; row < 64; row++) begin
      bank = row % T;  // Bank 0 gets rows 0,16,32,48; Bank 1 gets rows 1,17,33,49, etc.
      tile_row = row / T;  // Which tile row (0-3)
      
      for (col = 0; col < 64; col++) begin
        addr = tile_row * 64 + col;  // Address = tile_row * 64 + column
        
        bram_a_en = '0;
        bram_a_we = '0;
        bram_a_en[bank] = 1'b1;
        bram_a_we[bank] = 1'b1;
        bram_a_addr[bank] = addr[11:0];
        bram_a_din[bank] = mat[row][col];

        @(posedge clk);
      end
    end

    bram_a_en = '0;
    bram_a_we = '0;
    repeat (3) @(posedge clk);
    $display("  Matrix A write complete");
  endtask

  // Write full 64x64 Matrix B to BRAM B
  // Storage: Bank j holds columns j, j+16, j+32, j+48
  // Within each bank, store column-major
  task automatic write_matrix_64x64_b(input logic [63:0][63:0][W-1:0] mat);
    int row, col, bank, addr, tile_col;
    $display("  Writing 64x64 Matrix B to BRAM...");

    bram_b_en = '0;
    bram_b_we = '0;

    for (col = 0; col < 64; col++) begin
      bank = col % T;  // Bank 0 gets cols 0,16,32,48; Bank 1 gets cols 1,17,33,49, etc.
      tile_col = col / T;  // Which tile column (0-3)
      
      for (row = 0; row < 64; row++) begin
        addr = tile_col * 64 + row;  // Address = tile_col * 64 + row
        
        bram_b_en = '0;
        bram_b_we = '0;
        bram_b_en[bank] = 1'b1;
        bram_b_we[bank] = 1'b1;
        bram_b_addr[bank] = addr[11:0];
        bram_b_din[bank] = mat[row][col];

        @(posedge clk);
      end
    end

    bram_b_en = '0;
    bram_b_we = '0;
    repeat (3) @(posedge clk);
    $display("  Matrix B write complete");
  endtask

  // Stream one 16x16 tile through PE array
  task automatic stream_tile(
    input int tile_row_a,  // Which tile row in A (0-3)
    input int tile_col_b,  // Which tile column in B (0-3)
    input int tile_k       // Which K tile (0-3)
  );
    int cycle, i, addr;
    
    // Stream the tile using systolic pattern
    for (cycle = 0; cycle < (3*T-2); cycle++) begin
      bram_a_en = '0;
      bram_b_en = '0;

      for (i = 0; i < T; i++) begin
        if ((cycle >= i) && (cycle < i + T)) begin
          // For A: bank i gets data for PE row i
          bram_a_en[i] = 1'b1;
          addr = tile_row_a * 64 + tile_k * T + (cycle - i);
          bram_a_addr[i] = addr[11:0];
          
          // For B: bank i gets data for PE column i
          bram_b_en[i] = 1'b1;
          addr = tile_col_b * 64 + tile_k * T + (cycle - i);
          bram_b_addr[i] = addr[11:0];
        end
      end

      @(posedge clk);
    end

    bram_a_en = '0;
    bram_b_en = '0;
    repeat (5) @(posedge clk);
  endtask

  // Process one output tile C[tile_i][tile_j]
  task automatic process_output_tile(
    input int tile_i,  // Output tile row (0-3)
    input int tile_j   // Output tile column (0-3)
  );
    int k;
    
    $display("    Processing output tile C[%0d][%0d]", tile_i, tile_j);
    
    // Clear accumulators for first K tile
    pe_acc_clear_block = 1;
    @(posedge clk);
    pe_acc_clear_block = 0;
    @(posedge clk);

    // Process all K tiles (accumulate partial products)
    for (k = 0; k < NUM_TILES; k++) begin
      stream_tile(tile_i, tile_j, k);
    end

    // Drain the results
    pe_drain_pulse = 1;
    @(posedge clk);
    pe_drain_pulse = 0;
    repeat (T + 5) @(posedge clk);
    
    // Debug: Check a few values from this tile
    if (tile_i == 3 && tile_j == 0) begin
      $display("      Tile[3][0] PE results:");
      $display("        PE[15][0] = %d (for global C[63][0], expect %d)", 
               $signed(pe_acc_mat[15][0]), (63*64+1) % 128);
    end
  endtask

  // Write current PE results to BRAM C at specified tile location
  task automatic write_tile_to_bram_c(
    input int tile_i,
    input int tile_j
  );
    int i, j, global_row, global_col, bank, addr;

    // Debug: Show what we're about to write for first and last elements
    if ((tile_i == 0 && tile_j == 0) || (tile_i == 3 && tile_j == 3)) begin
      $display("      Writing tile [%0d][%0d]:", tile_i, tile_j);
      $display("        PE[0][0] = %0d -> C[%0d][%0d]", 
               $signed(pe_acc_mat[0][0]), tile_i*T, tile_j*T);
      $display("        PE[15][15] = %0d -> C[%0d][%0d]", 
               $signed(pe_acc_mat[15][15]), tile_i*T+15, tile_j*T+15);
    end

    for (i = 0; i < T; i++) begin
      for (j = 0; j < T; j++) begin
        // PE[i][j] corresponds to global position:
        global_row = tile_i * T + i;
        global_col = tile_j * T + j;
        
        bank = global_row % T;
        addr = (global_row / T) * 64 + global_col;
        
        bram_c_en = '0;
        bram_c_we = '0;
        bram_c_en[bank] = 1'b1;
        bram_c_we[bank] = 1'b1;
        bram_c_addr[bank] = addr[11:0];
        bram_c_din[bank] = pe_acc_mat[i][j];

        @(posedge clk);
      end
    end

    bram_c_en = '0;
    bram_c_we = '0;
    repeat (2) @(posedge clk);
  endtask

  // Complete 64x64 matrix multiplication
  task automatic matmul_64x64();
    int ti, tj;
    
    $display("\n  Starting 64x64 tiled matrix multiplication");
    $display("  Processing %0dx%0d tiles of size %0dx%0d", NUM_TILES, NUM_TILES, T, T);
    
    // Process each output tile
    for (ti = 0; ti < NUM_TILES; ti++) begin
      for (tj = 0; tj < NUM_TILES; tj++) begin
        process_output_tile(ti, tj);
        write_tile_to_bram_c(ti, tj);
      end
    end
    
    $display("  64x64 matrix multiplication complete!");
  endtask

  // Verify a few sample results from BRAM C
  task automatic verify_samples_64x64(
    input logic [63:0][63:0][ACCW-1:0] expected
  );
    int row, col, bank, addr;
    logic [ACCW-1:0] read_val;
    bit pass = 1;
    int p;
    int test_points[5][2];
    
    // Check corners and center
    test_points[0][0] = 0;   test_points[0][1] = 0;    // Top-left
    test_points[1][0] = 0;   test_points[1][1] = 63;   // Top-right
    test_points[2][0] = 63;  test_points[2][1] = 0;    // Bottom-left
    test_points[3][0] = 63;  test_points[3][1] = 63;   // Bottom-right
    test_points[4][0] = 32;  test_points[4][1] = 32;   // Center
    
    $display("\n  Verifying sample results from 64x64 multiplication:");
    
    // First, let's check what we expect
    $display("  Expected values:");
    $display("    Expected[0][0] = %d", expected[0][0]);
    $display("    Expected[0][63] = %d", expected[0][63]); 
    $display("    Expected[63][0] = %d", expected[63][0]);
    $display("    Expected[63][63] = %d", expected[63][63]);
    $display("    Expected[32][32] = %d", expected[32][32]);
    
    for (p = 0; p < 5; p++) begin
      row = test_points[p][0];
      col = test_points[p][1];
      
      // Correct addressing:
      // Row 32 is in bank 0 (32 % 16 = 0)
      // Row 32 is in the 3rd tile row (32 / 16 = 2)
      // So address = 2 * 64 + col
      bank = row % T;
      addr = (row / T) * 64 + col;
      
      $display("    Reading C[%0d][%0d]: bank=%0d, addr=%0d", row, col, bank, addr);
      
      bram_c_en = '0;
      bram_c_we = '0;
      @(posedge clk);
      
      // Set address and enable for read
      bram_c_en[bank] = 1'b1;
      bram_c_addr[bank] = addr[11:0];
      bram_c_we[bank] = 1'b0;
      
      // Wait for BRAM read latency
      @(posedge clk);
      
      // Capture data while enable is still high
      read_val = bram_c_dout[bank];
      
      // Disable bank
      bram_c_en[bank] = 1'b0;
      @(posedge clk);
      
      if (read_val !== expected[row][col]) begin
        $display("    ERROR at [%0d][%0d]: got %0d, expected %0d", 
                 row, col, $signed(read_val), $signed(expected[row][col]));
        pass = 0;
      end else begin
        $display("    ? C[%0d][%0d] = %0d", row, col, $signed(read_val));
      end
      
      @(posedge clk);
    end
    
    if (pass) begin
      $display("  ??? Sample verification PASSED!");
    end else begin
      $display("  ??? Sample verification FAILED!");
    end
  endtask

  // ------------------------------------------------------------
  // Test: 64x64 Matrix Multiplication
  // ------------------------------------------------------------
  task automatic test_64x64_matmul();
    logic [63:0][63:0][W-1:0]    mat_a, mat_b;
    logic [63:0][63:0][ACCW-1:0] expected;
    int i, j, k;
automatic int val;
 automatic int val1;
    $display("\n=== Test: 64x64 Matrix Multiplication ===");
    $display("  Using %0d-bit signed integers", W);
    $display("  PE Array: %0dx%0d", T, T);
    $display("  Tiles: %0dx%0d grid", NUM_TILES, NUM_TILES);

    // Initialize ALL matrices to zero first
    for (i = 0; i < 64; i++) begin
      for (j = 0; j < 64; j++) begin
        mat_a[i][j] = '0;
        mat_b[i][j] = '0;
        expected[i][j] = '0;
      end
    end

    // Simple diagonal test first to verify the data path
    // A = identity matrix, B = sequential values 1,2,3...
    // This should give C = B
    for (i = 0; i < 64; i++) begin
      for (j = 0; j < 64; j++) begin
        mat_a[i][j] = (i == j) ? 8'd1 : 8'd0;  // Identity matrix
        // Use modulo 128 to keep in signed byte range
        val1 = (i * 64 + j + 1) % 128;
        mat_b[i][j] = W'(val);
      end
    end
    
    // Calculate expected: C = A * B = I * B = B
    for (i = 0; i < 64; i++) begin
      for (j = 0; j < 64; j++) begin
         val = (i * 64 + j + 1) % 128;
        expected[i][j] = ACCW'(val);  // Sign-extend or zero-extend properly
      end
    end
    
    // Debug: Check specific values
    $display("  Matrix initialization check:");
    $display("    B[63][0] = %d (should be %d)", mat_b[63][0], (63*64+1) % 128);
    $display("    B[63][63] = %d (should be %d)", mat_b[63][63], (63*64+64) % 128);
    $display("    Expected[63][0] = %d", expected[63][0]);
    $display("    Expected[63][63] = %d", expected[63][63]);

    // Alternative test pattern (comment out above and use this for more complex test):
    /*
    for (i = 0; i < 64; i++) begin
      for (j = 0; j < 64; j++) begin
        mat_a[i][j] = W'((i + j) & 8'h0F);  // Small values 0-15
        mat_b[i][j] = W'((i - j + 64) & 8'h0F);  // Small values 0-15
      end
    end
    
    // Calculate expected result
    for (i = 0; i < 64; i++) begin
      for (j = 0; j < 64; j++) begin
        automatic longint signed sum = 0;
        for (k = 0; k < 64; k++) begin
          sum += $signed(mat_a[i][k]) * $signed(mat_b[k][j]);
        end
        expected[i][j] = sum[ACCW-1:0];
      end
    end
    */

    // Execute test
    write_matrix_64x64_a(mat_a);
    write_matrix_64x64_b(mat_b);
    matmul_64x64();
    verify_samples_64x64(expected);

    $display("=== End of 64x64 Test ===");
  endtask

  // ------------------------------------------------------------
  // Main Test Execution
  // ------------------------------------------------------------
  initial begin
    $display("========================================");
    $display("64x64 Matrix Multiplication Testbench");
    $display("T = %0d, W = %0d, ACCW = %0d", T, W, ACCW);
    $display("Matrix Size = %0dx%0d", MAT_SIZE, MAT_SIZE);
    $display("========================================");

    // Initialize signals
    bram_a_en = '0; bram_a_addr = '0; bram_a_din = '0; bram_a_we = '0; bram_a_be = '0;
    bram_b_en = '0; bram_b_addr = '0; bram_b_din = '0; bram_b_we = '0; bram_b_be = '0;
    bram_c_en = '0; bram_c_addr = '0; bram_c_din = '0; bram_c_we = '0; bram_c_be = '0;

    pe_acc_clear_block = 0;
    pe_drain_pulse = 0;

    // Reset sequence
    rst_n = 0;
    repeat (5) @(posedge clk);
    rst_n = 1;
    repeat (3) @(posedge clk);

    // Run the test
    test_64x64_matmul();

    $display("\n========================================");
    $display("Test Complete");
    $display("========================================\n");

    repeat (10) @(posedge clk);
    $finish;
  end

  // ------------------------------------------------------------
  // Timeout watchdog
  // ------------------------------------------------------------
  initial begin
    #10000000;  // Longer timeout for 64x64
    $display("\nERROR: Testbench timeout!");
    $finish;
  end

  // ------------------------------------------------------------
  // Waveform dump
  // ------------------------------------------------------------
  initial begin
    $dumpfile("tb_64x64_matmul.vcd");
    $dumpvars(0, tb_64x64_matmul);
  end

endmodule

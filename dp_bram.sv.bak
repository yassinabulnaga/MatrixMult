module dp_bram #(
    parameter int W          = 128,
    parameter int DEPTH      = 1024,
    parameter bit USE_BYTE_EN = 1,
    parameter int AW         = (DEPTH <= 1) ? 1 : $clog2(DEPTH),
    // 0 = WRITE_FIRST, 1 = READ_FIRST, 2 = NO_CHANGE (on write)
    parameter int RDW_MODE   = 0
) (
    input  logic              clk,
    input  logic              rst_n,

    // Port A
    input  logic              a_en,
    input  logic [AW-1:0]     a_addr,
    input  logic [W-1:0]      a_din,
    input  logic              a_we,
    input  logic [W/8-1:0]    a_be,
    output logic [W-1:0]      a_dout,

    // Port B
    input  logic              b_en,
    input  logic [AW-1:0]     b_addr,
    input  logic [W-1:0]      b_din,
    input  logic              b_we,
    input  logic [W/8-1:0]    b_be,
    output logic [W-1:0]      b_dout
);

  (* ramstyle = "M10K, no_rw_check" *)
  logic [W-1:0] mem [0:DEPTH-1];

  logic [W-1:0] a_q, b_q;

  initial begin
    if (USE_BYTE_EN && (W % 8) != 0)
      $fatal(1, "dp_bram: W must be a multiple of 8 when USE_BYTE_EN=1");
    if (RDW_MODE < 0 || RDW_MODE > 2)
      $fatal(1, "dp_bram: RDW_MODE must be 0/1/2");
  end

  // Byte-enable helper
  function automatic [W-1:0] mask_write(
      input [W-1:0]    din,
      input [W-1:0]    prev,
      input [W/8-1:0]  be
  );
    if (!USE_BYTE_EN) begin
      return din;
    end else begin
      automatic logic [W-1:0] res;
      int i;
      for (i = 0; i < W/8; i++) begin
        res[i*8 +: 8] = be[i] ? din[i*8 +: 8] : prev[i*8 +: 8];
      end
      return res;
    end
  endfunction

  // Port A
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      a_q <= '0;
    end else if (a_en) begin
      logic [W-1:0] prev   = mem[a_addr];
      logic [W-1:0] wdata  = mask_write(a_din, prev, a_be);

      if (a_we)
        mem[a_addr] <= wdata;

      unique case (RDW_MODE)
        0: a_q <= a_we ? wdata : mem[a_addr]; // write-first
        1: a_q <= prev;                       // read-first (old data)
        2: a_q <= a_we ? a_q : mem[a_addr];   // no-change on write
        default: a_q <= mem[a_addr];
      endcase
    end
  end

  // Port B
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      b_q <= '0;
    end else if (b_en) begin
      logic [W-1:0] prev   = mem[b_addr];
      logic [W-1:0] wdata  = mask_write(b_din, prev, b_be);

      if (b_we)
        mem[b_addr] <= wdata;

      unique case (RDW_MODE)
        0: b_q <= b_we ? wdata : mem[b_addr];
        1: b_q <= prev;
        2: b_q <= b_we ? b_q : mem[b_addr];
        default: b_q <= mem[b_addr];
      endcase
    end
  end

  // No extra pipeline: 1-cycle latency from a_q/b_q
  assign a_dout = a_q;
  assign b_dout = b_q;

endmodule

